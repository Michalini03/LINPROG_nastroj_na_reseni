\documentclass[a4paper,12pt]{article}

% Balíčky
\usepackage[czech]{babel} % Čeština
\usepackage[utf8]{inputenc} % Kódování UTF-8
\usepackage[T1]{fontenc} % Správné kódování znaků
\usepackage{amsmath,amssymb} % Matematické symboly
\usepackage{graphicx} % Obrázky
\usepackage{listings} % Zobrazení kódu
\usepackage{xcolor} % Barevný kód
\usepackage{hyperref} % Odkazy
\usepackage{geometry} % Nastavení okrajů
\geometry{a4paper, margin=2.5cm}

% Nastavení vzhledu kódu
\lstset{
    language=Python, % Nebo jiný jazyk, který používáte
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    breaklines=true,
    frame=single,
    extendedchars=true,
    literate={á}{{\'a}}1 {č}{{\v{c}}}1 {ď}{{\v{d}}}1 {é}{{\'e}}1 {ě}{{\v{e}}}1
             {í}{{\'i}}1 {ň}{{\v{n}}}1 {ó}{{\'o}}1 {ř}{{\v{r}}}1 {š}{{\v{s}}}1
             {ť}{{\v{t}}}1 {ú}{{\'u}}1 {ů}{{\r{u}}}1 {ý}{{\'y}}1 {ž}{{\v{z}}}1
             {Á}{{\'A}}1 {Č}{{\v{C}}}1 {Ď}{{\v{D}}}1 {É}{{\'E}}1 {Ě}{{\v{E}}}1
             {Í}{{\'I}}1 {Ň}{{\v{N}}}1 {Ó}{{\'O}}1 {Ř}{{\v{R}}}1 {Š}{{\v{S}}}1
             {Ť}{{\v{T}}}1 {Ú}{{\'U}}1 {Ů}{{\r{U}}}1 {Ý}{{\'Y}}1 {Ž}{{\v{Z}}}1
}

\begin{document}

% Titulní stránka
\begin{titlepage}

    \centering

    {\Large \textbf{{ZÁPADOČESKÁ UNIVERZITRA V PLZNI}\\[0.5cm]}}

    \large \textbf{{Fakulta aplikovaných věd}\\[7cm]}

    \large \textbf{{Základy programování pro IoT}}\\[0.7cm]

    \large {Semestrální práce na téma:}\\[0.5cm]

    \large \textbf{{Piškvorky}}\\[6cm]

    \begin{flushleft}
    \large Osobní číslo: A23B0406P
    \end{flushleft}
    \begin{flushleft}
        \large Autor: Michal Malík \hfill Datum: \today \\
    \end{flushleft}

\end{titlepage}
\newpage

% Obsah
\tableofcontents
\newpage

% Úvod
\section{Úvod}
Tato dokumentace popisuje realizaci semestrální práce v rámci předmětu \textit{Základy programování pro IoT}. Projekt se zaměřuje na vývoj aplikace pro \textbf{Internet věcí (IoT)}, která umožňuje monitorování a ovládání zařízení. Tento dokument shrnuje kroky návrhu, implementace, testování a nasazení projektu.\\
Téma práce se soustředí na známou hru piškvorky a možnost hrát "po síti" mezi dvěma hráči. Aplikace dokonce obsahuje i možnost nastavit si herní pole, podle čeho se mění i pravidla konkrétní hry.


% Návrh aplikace
\section{Analýza}
\subsection{Kód pro jedno zařízení}
Předtím, než jsem se pustil do programování aplikace, která mi dovolí hrát s někým přes internet, rozhodl jsem se, že vytvořím program, který mi dovolí hrát "couch-multiplayer" na jednom zařízení. \\
Rozhodl jsem se, že budu postupovat tímto způsobem:
\begin{enumerate}
	\item Možnost nastavení herní plochy
	\item Vytvoření herního pole
	\item Průběh hrou
	\item Vypsání vítěze či remízi
\end{enumerate}
\subsubsection{Možnost nastavení herní plochy}
Pro práci s uživatelem jsem využil fyzická tlačítka, které zařízení nabízelo. Abych uživatele informoval jaká velikost je nastavená, umístil jsem doprostřed obrazovky textové pole, které ve formátu <velikost>X<velikost> mění svojí hodnotu, podle funkcní \textbf{add\_one} a \textbf{drop\_one}. \\
Tyto funkce byly vnořeny do tlačítek A a C, prostřední tlačítko B sloužilo k potvrzení hodnoty pole. A k výskoku z jinak nekonečné smyčky, jenž reprezentovala výběr velikosti herní plochy.
\subsubsection{Vytvoření herní plochy}
Pro správu hry využívám dvě pole polí (matice). \textbf{State\_matrix}, kde se ukládá na hodnoty \textit{i}, \textit{j} symbol hráče, který zrovna hraje. Buď "X" nebo "O", pokud se na daném políčku ještě nehrálo, základní hodnotou je znak "-".\\
Druhá matice, s názvem \textbf{button\_matrix} má v sobě uložená tlačítka s naimplementovanou funkcí \textbf{change\_button}, jenž přebírá parametry \textit{i}, \textit{j}, které reprezentují adresu v matici. Funkce po zmáčknutí tlačítka změní hodnotu ve \textbf{state\_matrix} a i vnitřní text tlačítka, který se nachází na pozici \textit{i}, \textit{j} v matici \textbf{button\_matrix}. Při definici všech tlačítek, se zároveň vytváří jejich podoba na obrazu našeho zařízení.
\subsubsection{Průběh hrou}
Po nastavení herního pole program vklouzne do další smyčky, která neskonční dokud funkce \textbf{check\_game\_state} nevyhodnotí hru jako dokončenou. Pomocí globální proměnné \textbf{playing\_player} algoritmus ví, který hráč zrovna hraje, a pomocí této informace vkládá na správnou pozici správný znak. Vždy po nějakém čase, proběhne právě kontrola stavu hry. To je trochu nešťastný způsob ověřování, ale jelikož program fungoval i přesto správně, tak jsem už způsob, kdy se pole zkontroluje, neměnil.
\subsubsection{Vypsání vítěze či remízi}
Pokud funkce \textbf{check \_game\_state} vyhodnotí hru jako dohranou, vyskočí z cyklu a připraví výpis vítěze. Samotná funkce i samo zjistí kdo vyhrál, a podle toho nastaví globální proměnnou \textbf{player\_won}.
\subsection{Hra pro více hráčů}
Teď už jen sem musel přijít na to, jak hru budu moci ovládat přes dvě zařízení najednou, bez toho aniž by vznikali nějaké kolize. Proto jsem vytvořil druhý program, jenž byl skoro stejný jako původní pro jednoho hráče. Ten byl redukovaný o možnost nastavení velikosti pole a jediná jeho funkčnost byla v odehrávání.\\
Pro propojení mezi dvěma zařízení jsem se rozhodl použít MQTT server a k němu populární broker Mosquitto, který je k dispozici zdarma. Vytvořil jsem si 3 různé topici:
\begin{itemize}
	\item create\_field
	\item player\_one\_played
	\item player\_two\_played
\end{itemize}
\subsubsection{create\_field}
Na tento topic posílá data uživatel z prvního zařízení, říkejme mu hráč "X". Druhý hráč, který tento topic odebírá převezme hodnotu, převede ji na datový typ integer a s její pomocí sám sobě vytvoří pole. Druhý hráč, hráč "O" ale zatím stále čeká, než odehraje hráč "X", který je podle obecných pravidel piškvorek vždy na řadě první.
\subsubsection{player\_one\_played \& player\_two\_played}
Hráč "X" publikuje na \textbf{player\_one\_played} a hráč "O" z tohoto topicu odebírá a naopak. Hodnoty, které se na tyto topicy posílají, reprezentují souřadnice, na kterých daný hráč odehrál a podle toho přizpůsobí herní plochu na obou zařízeních.\\
Zároveň se zde nachází pojistka, která omezí možnost uživatele hrát, i když není na řadě s tahem.
\\
\\
Pro oba hráče zde probíhá už zmiňovaná funkce \textbf{check\_game\_state}, která i na obou zařízeních zařídí vypsání správného výsledku potom, co hra skončí.


% Implementace
\section{Implementace}
\subsection{Použité technologie}
\begin{itemize}
    \item Programovací jazyk: Python (redukovaná verze MicroPython)
    \item Komunikační protokol: MQTT
    \item Platforma: M5Stack Core 2
\end{itemize}

\subsection{Ukázka kódu}
\subsubsection{Nastavení herního pole}
Následuje ukázka kódu pro nastavení herního pole uživatelem:
\begin{lstlisting}
# Funkce pro fyzická tlačítka
def add_one():
    global field_size
    global field_size_text
    if(field_size == 10):
        field_size = 3
    else:
        field_size += 1
    field_size_text.set_text(str(field_size) + "x" + str(field_size))

def drop_one():
    global field_size
    global field_size_text
    if(field_size == 3):
        field_size = 10
    else:
        field_size -= 1
    field_size_text.set_text(str(field_size) + "x" + str(field_size))

# Průběh
while not btnB.wasPressed():
        btnA.wasPressed(drop_one)
        btnC.wasPressed(add_one)
        wait(0.2)
    
    screen.clean_screen()
    btnA.wasPressed()
    btnC.wasPressed()
    
    # Vytvoření matice a tlačítek
    state_matrix = create_square_matrix(field_size)
    button_matrix = create_square_matrix(field_size)
    
    create_field_by_size(field_size)
    m5mqtt.publish(str('create_field'), str(field_size), 0)
\end{lstlisting}
\subsubsection{Připojení k Wifi a nastavení MQTT serveru}
Následuje ukázka kódu, kde je ukázan způsob, jakým se zařízení připojí na MQTT server:
\begin{lstlisting}
# Připojení k Wi-Fi
label0 = M5Label('Not Connected', x=110, y=120, color=0x000, font=FONT_MONT_14, parent=None)
wifiCfg.doConnect('SSID', 'Password')

if not wifiCfg.wlan_sta.isconnected():
    for _ in range(5):  # Zkus připojit 5x
        wifiCfg.reconnect()
        if wifiCfg.wlan_sta.isconnected():
            break

if wifiCfg.wlan_sta.isconnected():
    # Připojení k serveru
    screen.set_screen_bg_color(0x9999ff)
    m5mqtt = M5mqtt('', 'test.mosquitto.org', 1883, '', '', 300)
    m5mqtt.subscribe(str('player_two_played'), player_two_played)
    m5mqtt.start()
    screen.clean_screen()
else:
    label0.set_text('Connection Failed')
\end{lstlisting}
\subsubsection{Odehrání}
Následuje ukázka kódu pro zpracování tahu hráče:
\begin{lstlisting}
def change_button(row, col):
    global playing_player
    global state_matrix
    global button_matrix
    global m5mqtt
    
    # Pokud tlačítko není označené
    if state_matrix[row][col] == "-":
        if playing_player == 2:
            return
        else:
            button_matrix[row][col].set_btn_text(STR_X)
            state_matrix[row][col] = STR_X
            playing_player = 2  # Přepnutí na hráče 2
            m5mqtt.publish(str('player_one_played'), str(str(row)+str(col)), 0)
\end{lstlisting}
\newpage
\subsubsection{Konečný výpis hry}
Na závěr se podíváme na kód, který má nastarost informovat hráče o výsledku:
\begin{lstlisting}
screen.clean_screen()
END = M5Label('THE END', x=83, y=69, color=0x000, font=FONT_MONT_34, parent=None)
winner = M5Label('Winner:', x=66, y=109, color=0x000, font=FONT_MONT_22, parent=None)
if(player_won == 1):
    player_who_won = M5Label('Player 1', x=163, y=109, color=0xfe0000, font=FONT_MONT_22, parent=None)
elif(player_won == 2):
    player_who_won = M5Label('Player 2', x=163, y=109, color=0x18ad03, font=FONT_MONT_22, parent=None)
elif(player_won == 0):
    player_who_won = M5Label('Draw', x=163, y=109, color=0x000, font=FONT_MONT_22, parent=None)
\end{lstlisting}


% Závěr
\section{Závěr}
Projekt úspěšně demonstruje základní koncepty IoT, který jsme se v předmětu KIV/ZPI naučili, včetně komunikace přes MQTT, MicroPython a ovládání zařízení. Dokumentace poskytuje popis návrhu a kódovou realizaci projektu.\\
Přišlo mi zajímé programovat poprvé něco na kus hardwaru a jsem rád, že to bylo v přívětivém programovacím jazyce jako je Python. Jediná škoda, která mě potrápila, byl nedostatek dokumentace k různým funkcím M5Stacku a trošku horší IDE UIFlow, které toho moc nenabízelo, až na možnost si pomoct Blocky pseudokódem.\\
I přesto jsem si nakonec programování M5Stacku užil a doufám, že si to někdy budu moci znova vyzkoušet.


\end{document}
